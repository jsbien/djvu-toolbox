#!/bin/sh

# Copyright Â© 2009 Jakub Wilk <ubanus@users.sf.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

set -e

getopt=`getopt -o '' --long lossless,clean,lossy,losslevel:,crcb:,dpi:,fg-slices:,bg-slices:,fg-subsample:,bg-subsample:,mask-filter: -n "$0" -- "$@"` || exit 1
eval set -- "$getopt"

if gm -version 2>/dev/null | grep -q -w GraphicsMagick
then
  convert='gm convert'
  identify='gm identify'
elif convert -version 2>/dev/null | grep -q -w ImageMagick && identify -version 2>/dev/null | grep -q -w ImageMagick
then
  convert='convert'
  identify='identify'
else
  printf 'Please install either GraphicsMagick or ImageMagick.\n'
  exit 1
fi

fg_subsample=6
fg_slices=100
bg_subsample=3
bg_slices=72+10+6+7
dpi=''
c44options=
cjb2options=''

filter=''
while true
do
  case "$1" in
    --crcb)
      c44options="$c44topions -crcb$2"; shift 2;;
    --dpi)
      dpi="$2"; shift 2;;
    --fg-slices)
      fg_slices="$2"; shift 2;;
    --bg-slices)
      bg_slices="$2"; shift 2;;
    --fg-subsample)
      fg_subsample="$2"; shift 2;;
    --bg-subsample)
      bg_subsample="$2"; shift 2;;
    --mask-filter)
      mask_filter="$2"; shift 2;;
    --lossless)
      cjb2options="$cjb2opions -lossless"; shift;;
    --clean)
      cjb2options="$cjb2opions -clean"; shift;;
    --lossy)
      cjb2options="$cjb2opions -lossy"; shift;;
    --losslevel)
      cjb2options="$cjb2opions -losslevel $2"; shift 2;;
    --)
      shift; break;;
    *)
      printf 'Internal error!\n' >&2; exit 1;;
  esac
done

if [ "$#" -eq 0 ] || [ "$#" -gt 2 ]
then
  printf 'Usage: %s [options] <input-image> [mask-image]\n' "$0"
  exit 1
fi

if tty <&1 >/dev/null
then
  printf "I won't write DjVu data to a terminal.\n" >&2
  exit 1
fi

input_image="$1"
mask_image="$2"

eval `$identify -format 'width=%w; height=%h; hdpi=%x; vdpi=%y' "$input_image" | sed -e 's/[.][0-9]\+//g' -e 's/[A-Z][A-Za-z]*//' | tr -dc '0-9a-z=;'`

[ -z "$dpi" ] && dpi=`printf 'sqrt(%d * %d)\n' "$hdpi" "$vdpi" | bc`
[ "$dpi" -lt 72 ] && dpi=72
[ "$dpi" -gt 6000 ] && dpi=6000

size="${width}x${height}"
fgwidth=$(( (width+fg_subsample-1)/fg_subsample ))
fgheight=$(( (height+fg_subsample-1)/fg_subsample ))
fgsize="${fgwidth}x${fgheight}"
bgwidth=$(( (width+bg_subsample-1)/bg_subsample ))
bgheight=$(( (height+bg_subsample-1)/bg_subsample ))
bgsize="${bgwidth}x${bgheight}"

tmpdir=`mktemp -d /tmp/c88.XXXXXXXX` || exit 1

convolve="-convolve 1,1,1,1,1,1,1,1,1 -threshold 99%"
if [ -z "$mask_image" ]
then
  $convert -scale "$fgsize!" -threshold '75%' -negate "$input_image" "$tmpdir/fgmask.pbm"
  $convert -scale "$bgsize!" -threshold '75%' $convolve "$input_image" "$tmpdir/bgmask.pbm"
  $convert -scale "$size!" -threshold '75%' "$input_image" "$tmpdir/mask.pbm"
else
  $convert -scale "$fgsize!" -negate "$mask_image" "$tmpdir/fgmask.pbm"
  $convert -scale "$bgsize!" $convolve "$mask_image" "$tmpdir/bgmask.pbm"
  $convert -scale "$size!" "$mask_image" "$tmpdir/mask.pbm"
fi

$convert -scale "$fgsize!" "$input_image" "$tmpdir/fg.ppm"
$convert -scale "$bgsize!" "$input_image" "$tmpdir/bg.ppm"

c44 $c44options -slice "$fg_slices" -mask "$tmpdir/fgmask.pbm" "$tmpdir/fg.ppm" "$tmpdir/fg.djvu"
c44 $c44options -slice "$bg_slices" -mask "$tmpdir/bgmask.pbm" "$tmpdir/bg.ppm" "$tmpdir/bg.djvu"

djvuextract "$tmpdir/fg.djvu" BG44="$tmpdir/fg.iw44" 2>/dev/null
djvuextract "$tmpdir/bg.djvu" BG44="$tmpdir/bg.iw44" 2>/dev/null

cjb2 $cjb2options "$tmpdir/mask.pbm" "$tmpdir/mask.djvu"

djvumake "$tmpdir/image.djvu" "INFO=$width,$height,$dpi" "Sjbz=$tmpdir/mask.djvu" "FG44=$tmpdir/fg.iw44" "BG44=$tmpdir/bg.iw44"

cat "$tmpdir/image.djvu"

rm -Rf "$tmpdir"

# vim:ts=2 sw=2 et
